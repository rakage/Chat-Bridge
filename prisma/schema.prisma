generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String              @id @default(cuid())
  email                  String              @unique
  name                   String?
  role                   Role                @default(AGENT)
  companyId              String?
  photoUrl               String?
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  password               String?
  accounts               Account[]
  documents              Document[]
  invitationsCreated     CompanyInvitation[] @relation("InvitedBy")
  invitationsAccepted    CompanyInvitation[] @relation("AcceptedBy")
  sessions               Session[]
  trainingSessions       TrainingSession[]
  company                Company?            @relation(fields: [companyId], references: [id])

  @@index([companyId])
  @@index([email])
  @@index([companyId, role])
  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Company {
  id                     String                  @id @default(cuid())
  name                   String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  documentChunks         DocumentChunk[]
  documents              Document[]
  freshdeskIntegration   FreshdeskIntegration?
  instagramConnections   InstagramConnection[]
  invitations            CompanyInvitation[]
  pages                  PageConnection[]
  providerConfig         ProviderConfig?
  telegramConnections    TelegramConnection[]
  trainingSessions       TrainingSession[]
  users                  User[]
  vectorSearches         VectorSearch[]
  widgetConfig           WidgetConfig?

  @@map("companies")
}

model ProviderConfig {
  id           String   @id @default(cuid())
  companyId    String   @unique
  provider     Provider @default(OPENAI)
  apiKeyEnc    String
  model        String
  temperature  Float    @default(0.3)
  maxTokens    Int      @default(512)
  systemPrompt String   @default("You are a helpful, brand-safe support assistant...")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("provider_configs")
}

model PageConnection {
  id                 String         @id @default(cuid())
  companyId          String
  pageId             String         @unique
  pageName           String
  pageAccessTokenEnc String
  verifyTokenEnc     String
  subscribed         Boolean        @default(false)
  autoBot            Boolean        @default(false)
  profilePictureUrl  String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  conversations      Conversation[]
  company            Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([companyId, subscribed])
  @@index([pageId])
  @@map("page_connections")
}

model InstagramConnection {
  id                   String   @id @default(cuid())
  companyId            String
  instagramUserId      String
  username             String
  displayName          String?
  accessTokenEnc       String
  profileData          Json?
  mediaCount           Int      @default(0)
  conversationsCount   Int      @default(0)
  messagingEnabled     Boolean  @default(false)
  isActive             Boolean  @default(true)
  autoBot              Boolean  @default(false)
  profilePictureUrl    String?
  accountType          String?  @default("business")
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  company              Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  conversations        Conversation[]

  @@unique([companyId, instagramUserId])
  @@index([companyId])
  @@index([companyId, isActive])
  @@index([instagramUserId])
  @@map("instagram_connections")
}

model TelegramConnection {
  id                 String         @id @default(cuid())
  companyId          String
  botId              String
  botUsername        String
  botName            String
  botTokenEnc        String
  isActive           Boolean        @default(true)
  autoBot            Boolean        @default(false)
  profilePictureUrl  String?
  webhookUrl         String?
  webhookSet         Boolean        @default(false)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  company            Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  conversations      Conversation[]

  @@unique([companyId, botId])
  @@index([companyId])
  @@index([companyId, isActive])
  @@index([botId])
  @@map("telegram_connections")
}

model Conversation {
  id                    String         @id @default(cuid())
  psid                  String
  platform              Platform
  status                ConvStatus     @default(OPEN)
  autoBot               Boolean        @default(false)
  lastMessageAt         DateTime       @default(now())
  assigneeId            String?
  notes                 String?
  tags                  String[]       @default([])
  customerEmail         String?
  customerPhone         String?
  customerAddress       String?
  customerName          String?
  freshdeskTickets      Json?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  meta                  Json?
  unreadCount           Int            @default(0) @map("unread_count")
  messages              Message[]

  // Polymorphic relation to either a Facebook Page, Instagram Connection, Telegram Bot, or Widget
  pageConnectionId      String?
  instagramConnectionId String?
  telegramConnectionId  String?
  widgetConfigId        String?
  pageConnection        PageConnection?      @relation(fields: [pageConnectionId], references: [id], onDelete: Cascade)
  instagramConnection   InstagramConnection? @relation(fields: [instagramConnectionId], references: [id], onDelete: Cascade)
  telegramConnection    TelegramConnection?  @relation(fields: [telegramConnectionId], references: [id], onDelete: Cascade)
  widgetConfig          WidgetConfig?        @relation(fields: [widgetConfigId], references: [id], onDelete: Cascade)

  @@unique([pageConnectionId, psid])
  @@unique([instagramConnectionId, psid])
  @@unique([telegramConnectionId, psid])
  @@unique([widgetConfigId, psid])
  @@index([pageConnectionId, status, lastMessageAt])
  @@index([instagramConnectionId, status, lastMessageAt])
  @@index([telegramConnectionId, status, lastMessageAt])
  @@index([widgetConfigId, status, lastMessageAt])
  @@index([platform, status])
  @@index([lastMessageAt])
  @@index([status, autoBot])
  @@index([assigneeId])
  @@index([createdAt])
  @@index([unreadCount])
  @@map("conversations")
}

enum Platform {
  FACEBOOK
  INSTAGRAM
  TELEGRAM
  WIDGET
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  role           MsgRole
  text           String
  providerUsed   Provider?
  meta           Json?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([conversationId, role])
  @@index([createdAt])
  @@index([role])
  @@map("messages")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Document {
  id               String            @id @default(cuid())
  companyId        String
  filename         String
  originalName     String
  fileType         DocumentType
  fileSize         Int
  filePath         String
  extractedText    String?
  status           DocumentStatus    @default(UPLOADED)
  uploadedById     String
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  chunks           DocumentChunk[]
  company          Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  uploadedBy       User              @relation(fields: [uploadedById], references: [id])
  trainingSessions TrainingSession[] @relation("DocumentToTrainingSession")

  @@index([companyId])
  @@index([companyId, status])
  @@index([uploadedById])
  @@index([createdAt])
  @@map("documents")
}

model TrainingSession {
  id           String         @id @default(cuid())
  companyId    String
  status       TrainingStatus @default(PENDING)
  startedAt    DateTime?
  completedAt  DateTime?
  errorMessage String?
  progress     Int            @default(0)
  startedById  String
  metadata     Json?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  company      Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  startedBy    User           @relation(fields: [startedById], references: [id])
  documents    Document[]     @relation("DocumentToTrainingSession")

  @@index([companyId])
  @@index([companyId, status])
  @@index([status])
  @@index([createdAt])
  @@map("training_sessions")
}

model DocumentChunk {
  id          String   @id @default(cuid())
  documentId  String
  companyId   String
  chunkIndex  Int
  content     String
  tokenCount  Int?
  embeddingId String?
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  embedding   Float[]
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([companyId])
  @@index([documentId])
  @@index([companyId, documentId])
  @@map("document_chunks")
}

model VectorSearch {
  id          String   @id @default(cuid())
  companyId   String
  query       String
  results     Json
  resultCount Int
  createdAt   DateTime @default(now())
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([companyId, createdAt])
  @@map("vector_searches")
}

model FreshdeskIntegration {
  id              String   @id @default(cuid())
  companyId       String   @unique
  domain          String
  apiKeyEnc       String
  enabled         Boolean  @default(false)
  autoCreate      Boolean  @default(true)
  defaultPriority Int      @default(2)
  defaultStatus   Int      @default(2)
  defaultSource   Int      @default(7)
  defaultGroupId  BigInt?
  escalationRules Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  company         Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("freshdesk_integrations")
}

model ConversationLastSeen {
  id             String   @id @default(cuid())
  userId         String
  conversationId String
  lastSeenAt     DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([userId, conversationId])
  @@index([userId])
  @@index([conversationId])
  @@map("conversation_last_seen")
}

model WidgetConfig {
  id                String         @id @default(cuid())
  companyId         String         @unique
  widgetName        String         @default("Chat Widget")
  primaryColor      String         @default("#2563eb")
  accentColor       String         @default("#1e40af")
  welcomeMessage    String         @default("Hi! How can we help you?")
  placeholderText   String         @default("Type your message...")
  position          String         @default("bottom-right")
  autoOpen          Boolean        @default(false)
  autoOpenDelay     Int            @default(3000)
  autoBot           Boolean        @default(false)
  enabled           Boolean        @default(true)
  allowedDomains    String[]       @default([])
  collectName       Boolean        @default(true)
  collectEmail      Boolean        @default(true)
  collectPhone      Boolean        @default(false)
  requireEmail      Boolean        @default(true)
  showPoweredBy     Boolean        @default(true)
  customCss         String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  conversations     Conversation[]
  company           Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("widget_configs")
}

enum Role {
  OWNER
  ADMIN
  AGENT
}

enum Provider {
  OPENAI
  GEMINI
  OPENROUTER
}

enum ConvStatus {
  OPEN
  SNOOZED
  CLOSED
}

enum MsgRole {
  USER
  AGENT
  BOT
}

enum DocumentType {
  PDF
  DOC
  DOCX
  TXT
}

enum DocumentStatus {
  UPLOADED
  PROCESSING
  PROCESSED
  ERROR
}

enum TrainingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model CompanyInvitation {
  id               String    @id @default(cuid())
  code             String    @unique
  companyId        String
  email            String?
  invitedByUserId  String
  acceptedByUserId String?
  status           InvitationStatus @default(PENDING)
  isActive         Boolean   @default(true)
  maxUses          Int       @default(1)
  usedCount        Int       @default(0)
  expiresAt        DateTime
  acceptedAt       DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  company          Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invitedBy        User      @relation("InvitedBy", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  acceptedBy       User?     @relation("AcceptedBy", fields: [acceptedByUserId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([email])
  @@index([status])
  @@index([invitedByUserId])
  @@index([isActive])
  @@map("company_invitations")
}

model RagMessageCache {
  id          String   @id @default(cuid())
  companyId   String
  messageHash String   // Hash of normalized message for fast lookup
  message     String   // Original message text
  response    String   // Cached bot response
  context     Json?    // RAG context (documents used)
  usage       Json?    // Token usage info
  hitCount    Int      @default(1) // Track how many times this cache was used
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastUsedAt  DateTime @default(now())

  @@unique([companyId, messageHash])
  @@index([companyId])
  @@index([companyId, messageHash])
  @@index([lastUsedAt]) // For cleanup of old cache entries
  @@map("rag_message_cache")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}
